http://games-cn.org/forums/topic/%E3%80%90%E6%80%BB%E7%BB%93%E3%80%91msaa%E4%B8%AD%E9%BB%91%E7%BA%BF%E9%97%AE%E9%A2%98%E7%9A%84%E5%87%BA%E7%8E%B0%E5%8E%9F%E5%9B%A0%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/

你是没有用四倍的深度缓存和颜色缓存吗？只是用了一个暂时的2X2大小的缓存用来暂存颜色，然后最后通过判断经过平均再写入总的颜色缓存中？
如果是这样的话你的子采样点的颜色是怎么取的呢，我不知道你具体是怎么实现的，但就我看来如果是取自原大小的颜色缓存的话就会出现黑边，
因为假设绿色三角形先被渲染，蓝色后被渲染，那么在绿色三角形被渲染时，绿色三角形的边界就被写入了（绿色+黑色）的颜色，然后渲染蓝色三角形时，
在两个三角形的相交处，子采样点首先肯定要取颜色，那么此时就取了绿三角形边界的颜色，也就是前面提到的（绿色+黑色）的颜色，此时这个相交处肯
定至少有一个蓝三角形的子采样点满足深度测试的，而三角形内部测试的话相交处很明显是在蓝色三角形内部，所以也会通过，所以在渲染蓝色三角形的情
况下，在渲染相交处的像素时，会写入（绿色+黑色）+（蓝色）也就是（绿色+黑色+蓝色）的颜色，而不是（绿色+蓝色）

如果用和最终颜色缓存独立的4倍大的子采样点颜色缓存的话，子采样点中都是没被平均过的颜色，注意，这个缓存存的是每个子采样点自己的颜色，不需要平均，
也就是黑色就是黑色，绿色就是绿色，显而易见，在这个颜色缓存中，在两个三角形相交处要么是绿色（说明该子采样点在绿三角形内），要么是蓝色（说明该
子采样点在蓝色三角形内）。因此在渲染蓝三角形时，相交处取到的肯定是绿色和蓝色而没有黑色，所以最终写入正真的像素的颜色缓存时用的就是（绿色+蓝色），
此时不用平均（注意，平均是拿子采样点的颜色缓存中的颜色进行平均，然后直接写入最终的像素颜色缓存，不需要取出最终的像素颜色缓存里的颜色，这也就避免
了先写入了黑色，后来就没法消除黑色的弊端）

像我最开始也没用四倍大的子采样点的颜色缓存，每次都是子采样点判断后直接平均颜色写入颜色缓存，这样的话黑色只要写入了颜色缓存，后面因为怎么样都是
在拿它做平均，所以一直会有黑色混入，最终颜色也就显然不正确了

你这个图或许只是巧合，你可以交换两个三角形的深度，看下会不会出错。我一开始没用四倍大的子采样点颜色缓存也能得到“看似”正确的结果，但是经过大佬
提醒，我交换了下深度发现出错了，然后才改正的。
因为我不知道你具体是怎么实现的，所以如果你怎么变都是对的，那就坚持你自己的做法和想法吧，因为你那样肯定是对的